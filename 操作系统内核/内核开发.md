# 内核开发

## 实模式和保护模式

### 实模式

即16位模式，将整个物理内存看成分段的区域，程序代码和数据位于不同的区域，操作系统内核和用户程序并没有区别对待，没有权限之分。而且每一个指针都能指向实际的物理地址，最大可寻址空间为1MB(20根地址线)。**实模式下可以使用BIOS中断**。

### 保护模式

有32根地址线可询指，可采用分段管理和分页管理，为存储共享和保护提供了硬件支持。CPU的通用寄存器采用的是32位寄存器。保护模式增加了权限限制。**保护模式不可使用BIOS中断，因为BIOS只提供16位硬件操作**。

## 语言和编译环境

采用NASM和GCC结合。首先使用NASM编写引导程序，将内核的所有代码写入内存中指定的位置，再跳转到该位置执行内核程序。
NASM程序主要使用了BIOS中断以及编写一些简单的可视化汇编程序。C语言程序则利用NASM程序中的函数为辅助函数，封装了更灵活的接口。

## GCC和NASM的结合

由于GCC生成的是32位代码，NASM编译非二进制文件时也是默认生成32位代码，而实模式下的代码是16位的，所以为了让C语言代码可以在实模式下运行，需要在C程序的开头使用内嵌汇编指令“__asm__(".code16gcc\n")”，以形成可与NASM指令汇合编译的代码。而所有汇编程序的开头皆添加“[bits 16]”使得NASM编译成非二进制文件时产生的是16位代码。

在C程序中调用汇编函数时会把当前地址压栈，这时候压入的是32位地址，所以在汇编函数返回时需要弹出4个字节(1个字节=8位)，可以采用“ret 2”指令，表示除了ret本身弹出2个字节外，多弹出2个字节。弹出的4个字节中只有前两个字节指向了函数的地址。且**函数的压栈顺序是先将参数列表中的参数从右往左压栈，最后压入函数地址**。

被C程序调用的汇编函数必须在汇编程序中声明为global，且函数名必须以下划线开头，表明该函数可以被其他程序调用。
而C程序中则要以extern关键字声明**对应的函数**为外部函数，函数名省略开头的下划线。

## 编译和链接指令

1. nasm -f elf32 文件名.asm -o 文件名.o

2. gcc -march=i386 -m32 2 -mpreferred-stack-boundary=2 -ffreestanding -c 文件名.c -o 文件名.o

    - i386指使用i386指令集编译

    - m32指生成32位代码

    - mpreferred-stack-boundary=2指栈指针按2*2=4 4字节对齐

    - ffreestanding使输出程序能独立运行

3. ld.exe -m i386pe C文件(可以有多个).o ASM文件(可以有多个).o -Ttext 0x8100(链接文件要加载到的内存位置) -o 目标文件.tmp

4. objcopy -O binary 目标文件.tmp 目标文件.bin 将tmp文件转为二进制文件

其中3中的ld.exe是一个可执行的链接程序 需要下载

## 什么是内核

在完成实验后我的感受就是，操作系统内核就是操作系统的内部实现，内核中封装了软件与硬件的交互接口(如我们常用的输入/输出接口)，实现了程序的调度方式等众多计算机的基础操作。还有更复杂一些的多进程、多线程的互斥和调度问题。

而我们常用的应用程序则是基于操作系统，利用其提供的接口实现了方便用户使用的应用。

## 基础模块

### I/O模块

负责字符串的输入和输出，要直接与键盘和屏幕交互，所以要在汇编程序中采用中断的方式。而C程序只能调用汇编函数，封装接口。

1. 输入字符串：调用BIOS的16H中断的0号功能，等待键盘输入。该功能每次从键盘读取一个字符并将字符写入AL寄存器。在C程序中调用汇编函数时，汇编函数会将AL寄存器中的值作为函数返回值返回到C程序中。

    - NASM程序：

        ```nasm
        _input:
            mov ah,0
            int 16h
            ret 2
        ```

    - C程序

        ```cpp
        void get_input(char *buf){
            char ch=13;     // 回车
            int i=0;
            while(1){
                ch=input();     // 汇编函数
                if(ch=='\r'){   // 回车 表示输入结束
                    output('\n');   // 打印回车和换行字符
                    output('\r');
                    break;
                }
                else if(ch==8){ // 回退键
                    if(i==0) continue;  // buf中还没有字符
                    backspace();        // 汇编函数 回退
                    i=i-1;
                }
                else{           // 正常输入
                    buf[i]=ch;
                    i=i+1;
                    output(ch); // 打印到屏幕
                }
            }
            buf[i]='\0';    // 字符串结尾
        }
        ```

2. 输出字符串：调用BIOS的10H中断的0EH功能，将AL寄存器上的字符打印到屏幕后光标自动右移一位。由C程序调用汇编函数并将要打印的字符作为参数传递给汇编函数。前面说过C程序调用汇编函数时的参数入栈和函数地址入栈都是每次**4个字节**入栈，因此传入的第一个参数的起始字节所在的位置是esp+4。

    - NASM程序：

        ```nasm
            _output:
                mov al,[esp+4]  ; 取esp+4位置上的内容到al寄存器
                mov bl,07h      ; 设置要打印的字符的属性
                mov ah,0eh      ; 0eh号功能
                int 10h
                ret 2
        ```

    - C程序：

        ```cpp
            void get_output(char *buf){
                int i=0;
                for(;buf[i]!='\0';++i){
                    output(buf[i]);
                }
            }
        ```

3. 回退功能：实际上是回退光标，在上一个位置打印空格，“伪造”回退效果。也是利用光标操作相关的中断。需要注意在行首回退时会回退到上一行的行尾。

    - NASM程序：

        ```nasm
            _backspace:
                mov ah,3    ; 读光标位置 信息存在各寄存器中
                mov bh,0
                int 10h

                cmp dl,0    ; dl寄存器存光标所在的列
                je lastlow

                dec dl      ; 所在列减1
                mov ah,2    ; 设置光标位置
                int 10h

                call help_bp    ; 将要删除的字符的位置设置为空格
                ret 2

                lastrow:    ; 光标需要回到上一行的情况
                dec dh      ; dh寄存器存光标所在的行
                mov dl,79   ; 列最大为79
                mov ah,2    ; 设置光标位置
                int 10h
                call help_bp
                ret 2

                help_bp:    ; 将要删除的字符的位置设置为空格
                mov al,20h  ; al寄存器存要打印的字符
                mov bl,7
                mov ah,0eh
                int 10h
                ret
        ```

### 磁盘读写

我们将要运行的汇编程序写在软盘上，写的位置(所在柱面、扇区)由自己设计安排，在内核中设计函数调用BIOS与磁盘交互的中断，读取磁盘上指定区域的内容并加载到内存中的指定位置。然后我们可以在汇编程序中直接跳转到这个内存中的位置执行已经加载的代码。

1. 读软盘：

    ```nasm
        _loaddisk:
            mov ax,cs
            mov es,ax
            mov bx,[esp+20]     ; 代码要加载到的内存中的位置
            mov ah,2
            mov dl,0
            mov cl,[esp+16]     ; 代码起始扇区
            mov dh,[esp+12]     ; 磁头
            mov ch,[esp+8]      ; 柱面
            mov al,[esp+4]      ; 扇区数
            int 13h             ; 要读取的扇区数
            ret 2
    ```

2. 运行内存指定位置上的程序：

    ```nasm
        _run:
            call [esp+4]    ; 位置
            ret 2
    ```

这种方式下，程序要装入内存的哪个位置完全由自己决定并记录。
