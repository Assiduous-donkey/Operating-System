# 中断机制

## 异步事件

在操作系统中，许多活动或事件可能并发进行，随时可能发生或结束，不可预测。**计算机硬件系统提供中断技术，支持CPU与外部设备的并发工作**。也利用中断技术处理硬件错误、实现软件保护和信息安全等。

## 中断技术

中断(interrupt)是指**对处理器正常处理过程的打断**。在程序执行过程中强制性转移到相应的处理程序

### 硬中断

也称为外部中断，由外部(主要是外部设备)的请求引起的，包括：

    - 时钟中断：由计时器产生，等间隔触发

    - I/O中断：由I/O控制器产生，通知操作完成或操作出错

    - 硬件故障中断：故障产生，如掉电或内存奇偶校验错误

### 软中断

也称为内部中断，由指令的执行引起的中断。如中断指令(INT)

### 异常/程序中断

由指令执行结果产生，如溢出、非法指令。

### X86的中断系统

采用32位的中断向量，映射到256种不同类型的中断处理程序的地址。有两条外部中断请求线：NMI(不可屏蔽中断)和INTR(可屏蔽中断)。

INTR：CPU是否响应INTR线上出现的中断请求，取决于标志寄存器FLAGS中的IF标志位的状态是否为1(可用于开(STI)/关(CLI)中断)。
系统复位后或者任一中断被响应后会置IF=0(关中断)，若想允许中断嵌套则需要在中断处理程序中用STI指令来打开中断。

NMI：NMI线上的中断请求不受标志位IF的影响。CPU在执行完当前指令后会立即响应。**不可屏蔽中断的优先级要高于可屏蔽中断**。

### 中断处理过程

1. 保护断点现场：

    - 将标志寄存器FLAGS压栈，然后将它的IF和TF标志位(TF=1时CPU进入单步执行方式)置零。

    - 再将当前的代码段寄存器CS和指令指针寄存器IP压栈

2. 执行中断处理程序

    - 处理器将中断号×4(每个中断号在中断向量表中占4个字节)得到该中断的入口在中断向量表中的偏移地址

    - 从中断向量表中依次取出中断程序的偏移地址和段地址，用它们对应地设置IP和CS寄存器，从而让处理器开始执行中断处理程序

    - 由于IF标志位置零，处理器不再响应硬件中断，若希望更高优先级的中断嵌套则可以在中断处理程序中使用STI开中断。

3. 返回到断点继续执行

    - **所有中断处理程序的最后一条指令必须是中断返回指令(IRET)**，这将导致处理器依次从栈中弹出IP、CS和FLAGS的原始内容，然后转到原来入栈的IP和CS的位置继续执行。

### 8259A芯片

8259A是一种可编程中断控制器(programmable interrupt controller)，通过IN/OUT指令来读写这些端口从而操作中断控制器。
主要功能有：

    - 接受外部的中断请求并进行判断，选中当前优先级最高的中断请求，然后将此请求送到CPU的INTR端

    - 当CPU响应中断并进入中断子程序的处理过程后，仍负责对外部中断请求的管理

8259A芯片中包含三个内部寄存器：

    - IMR(中断屏蔽寄存器)，用作过滤被屏蔽的中断

    - IRR(中断请求寄存器)，用作暂时放置未被进一步处理的中断

    - ISR(在使用的中断)，当一个中断正在被CPU处理时ISR中的对应位被置位

8259A还有一个优先级分解器，当多个中断同时发生时将高优先级者优先传递给CPU

X86处理器采用两个级联的8259A芯片作为外设向CPU申请中断的代理接口，使1条INTR线扩展为15条中断请求线

### 中断向量表

X86计算机在启动时会自动进入实模式，BIOS会初始化8259A的各中断线的类型。并在内存的低位区(0-1023,共1KB)创建含有256个中断向量的表，每个向量占4个字节，格式为————16位段值:16位偏移值

**当系统进入保护模式时，中断向量表失效**，改用中断描述表，这时必须自己编程来定义8259A的各个软中断类型号和对应的处理程序。

## 编写中断程序

1. 结束中断的操作：

    ```nasm
        mov al,20h  ;发送EOI(中断结束)命令，将某个标志位置1
        out 20h,al  ;发送命令到主8259A(20h端口)
        out a0h,al  ;发送命令到从8259A(a0h端口)
        iret
    ```

2. 修改时钟中断：等同与自写中断程序

    ```nasm
        _init_int8:
            xor ax,ax   ;将ax置零，因为中断向量表是从段地址为0处开始
            mov es,ax
            mov ax,cs   ;当前的代码段
            mov word[es:20h],INT_8    ;8号中断向量的起始字节为4*8=32=20h
            mov word[es:22h],ax
            mov ds,ax   ; 数据段与代码段在同一段 因为我们没有区分
            mov es,ax
            ret 2

        INT_8:
            pushad  ; 将8个通用寄存器压栈
            push ds
            push es
            mov ax,cs   ; 修改各段地址为当前代码段
            mov ds,ax
            push 0      ; 与C程序的32位兼容 因为下面的call只压入2个字节
            call _time_pro  ; 调用C程序所写的中断程序
            mov al,20h  ; 中断结束指令
            out 20h,al
            out a0h,al
            pop es
            pop ds
            popad       ; 8个通用寄存器出栈
            iret
    ```

上述程序使得每次触发时钟中断则运行time_pro程序。

总结一下流程，就是先将中断向量所映射的4个字节的中断程序地址换为我们自己编写的中断程序的地址(低地址存放IP————偏移量，高地址存放CS————起始段地址)。在自己编写的中断程序中要保护各个可能将被修改的寄存器。

## 内核与中断

操作系统内核的一项基本任务就是捕捉和响应各种中断事件，实现硬件系统操作的控制、为进程提供功能服务和安全保护。

## 系统调用

操作系统除了执行用户程序之外还需要为用户程序开发提供一些常用的服务，这些服务常写为“系统调用”的形式。

操作系统提供的服务可以用多种方式供用户程序使用：

1. 子程序库静态链接：采用子程序调用的方式(如汇编语言中的call指令)调用操作系统提供服务的子程序，将程序静态链接到用户程序代码中。这种方式执行快但占用的空间多。

2. 内核子程序软中断调用：采用软中断方式(如汇编语言中的int指令)调用操作系统提供服务器的子程序。系统服务的子程序在内核，这种方式的优点是程序效率高且被所有用户程序代码共享，有利于节省内存。

3. 子程序库动态链接：操作系统在运行时响应子程序调用，加载响应的服务子程序并链接至用户空间。这种方式可由多方提供服务程序但是耗时多且实现复杂。

系统调用就是通过软中断调用的方式实现。因为操作系统要提供的服务多但中断向量有限，因此实际的做法是专门指定一个中断号作为所有系统调用程序的总入口，然后再将服务程序用功能号区分。

具体实现：选择21H号中断为系统调用

```nasm
    _system_int_init:   ; 修改21H号中断为自己编写的系统调用程序
        push es
        xor ax,ax
        mov es,ax
        mov ax,cs
        mov word[es:84h],system_int
        mov word[es:86h],ax
        pop es
        ret 2
    
    system_int:
        pushad
        push ds
        push es
        @1: ; 1号功能
        cmp ah,1    ; ah作为选择系统调用的功能号的参数
        jnz @2      ; 不是选择1号功能则跳转到2号功能看看 线性检查
        call 1号功能的程序
        jmp finish  ; 完成系统调用
        @2: ; 2号功能
        ...实现方式同上
        ...
        finish:
        pop es
        pop ds
        popad
        iret
```
