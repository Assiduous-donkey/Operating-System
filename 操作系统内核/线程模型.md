# 线程模型

采用UNIX类似的线程模型，在改模型中线程可以看作一个进程的不同执行路线，一个进程可以包含多个线程用于执行不同的操作。即采用类似fork()的形式来实现多线程。

内核级线程：由内核进程创建、销毁以及调度的线程。
用户级线程：进程利用线程库提供的操作来控制线程，不需要内核的参与。

根据上面两个概念涉及线程模型，可以知道：

1. 线程在进程内部创建，是进程的一个分支，因此**线程将与进程共享代码段和全局数据段(线程的CS和DS都将与进程的相同)**。

2. 由于线程有自己的执行任务，所以它**需要有自己的栈空间**。可以通过将线程的SS和SP执行一段未使用的空间来实现。

3. 由于线程是进程执行的分支，所以进程必须等待其所有线程执行完成后才可退出。因此也需要实现线程同步函数。

4. 线程结束时应该告知进程。

5. 内核从原先的进程调度修改为线程调度，调度的最小单位为线程。

## 实现思路

### 线程创建

**线程与其所属的进程拥有相同的全局数据段和代码段，为线程分配栈空间**。

由于不同线程执行不同任务，在线程结束后及时释放资源防止资源浪费。如果我们在每个线程的代码的最后都调用线程结束的系统调用，会使得我们的模型不具备可扩展性且没有适用性(用户编写程序时需要知道哪一个系统调用是在释放资源)。
为此，我们可以利用函数执行完成后会弹出栈顶字节(一般来说是函数返回地址)这一特点，**在线程创建时将线程结束的系统调用的入口地址放置于线程的栈顶，这样线程结束后就会自动调用该函数释放资源**。

为了让内核可以以线程为单位进行调度，需要在内核在内核中为线程创建自己的控制块(TCB)，并将该TCB的IP设为线程函数的入口地址。
而这样的话我们既要调度线程，又要调度进程，因为两者的控制块不同所以需要区别对待。但我们也这样**将线程映射到进程，然后共同用PCB进行调度，因为TCB包含的内容可以被PCB覆盖**。

#### 线程控制块

```cpp
    const int thread_number 6;  // 内核中可以共同存在的最大线程数
    typedef struct TCB{
        int tid,pid;
        int ss,sp;
    }TCB;
    TCB TCBlist[thread_number];
    int used[thread_number];    // used[1]=0/1表示tid=1未/已经被使用
    int pid2tid[内核可以调度的进程总数];    // pid2tid[1]=2表示内置中pid为1的进程实际上是tid为2的线程
```

#### 创建过程

```cpp
    int thread_create(void(*function_addr)(),void *arg){
        /* 输入参数为要执行的函数地址以及函数需要的参数 */
        __asm__("cli\n");   // 采用内嵌汇编 关中断 实现原子操作
        int tid=get_tid();  // 申请可用的tid
        TCBlist[tid].tid=tid;
        为该线程分配栈空间
        设置TCBlist[tid].ss和TCBlist[tid].sp
        int ss=TCBlist[tid].ss;
        // 初始栈底 因为要压入 线程要执行的函数的地址、参数列表以及线程创建函数的返回地址
        int sp=TCBlist[tid].sp+4*3;
        push_information(ss,sp,tid,thread_exit,arg);
        // 线程映射到进程 汇编函数
        int pid=thread_2_process(ss,TCBlist[tid].sp,function_addr);
        TCBlist[tid].pid=pid;
        pid2tid[pid]=tid;
        __asm__("sti\n");
        return tid;
    }
```

用汇编函数将线程结束函数的地址压入线程执行函数的栈中

```nasm
    push_information:
    保存需要借助的寄存器...(mov word[save_xx],xx)
    mov ax,word[esp+4]  ; ss
    mov bx,word[esp+8]  ; sp
    mov cx,word[esp+12] ; tid
    mov dx,word[esp+16] ; 线程结束函数的地址 addr
    mov di,word[esp+20] ; 参数列表首地址 arg
    mov ss,ax
    mov sp,bx
    push 0      ; tid入栈
    push cx
    push 0
    push di     ; 参数列表首地址
    push 0
    push dx     ; 线程结束函数的地址

```

正常的函数调用的压栈过程为：首先将BP寄存器指向当前的SP(创建栈空间)，再依次将参数列表上的参数按照从右往左的顺序压栈，然后将函数的返回地址压栈。函数运行结束后会自动跳转到该返回地址，然后将SP指向现有的BP，将BP指向原来的BP(释放栈空间)
在我们自己编写的程序中，我们已知要入栈的字节数，所以可以免去BP寄存器的修改。

要使得线程执行完指定函数后跳转到线程结束函数处执行，就需要将线程结束函数的地址最后压栈(代替原有的返回地址)

线程到进程的映射调用了thread_2_process函数，该函数是一个汇编函数，使用了系统调用的某个功能，该功能的实现如下：

```cpp
    void do_thread_create(int ss,int sp,void *function_addr){
        int pid=get_pid();  // 申请pid
        PCBlist[pid].IP=function_addr;  // 线程将要执行的函数的地址
        thread_init(ss,sp,pid); // 对线程映射到的PCB做简单的初始化(与当前进程共享代码段和全局数据段)
        PCBaddr->AX=pid;
        PCBaddr->threads+=1;    // 当前进程下的线程数+1
    }
```

需要注意的是thread_init中初始化线程映射到的PCB时，需要指明该线程是由哪个进程创建的，即令“线程映射到的PCB->FID=当前进程(PCBaddr)->PID”

梳理一下流程：

1. 创建线程时需要提供线程要调用的函数以及该函数所需的参数。整个创建操作封装为原子操作(在C程序中使用了内嵌汇编指令关中断和开中断)

2. 首先申请一个tid，然后为线程分配栈空间

3. 然后将线程执行时需要的参数压栈，以及处理线程结束时的函数地址压栈，使得线程执行结束时自动跳转执行释放资源的操作。(汇编程序)

4. 将线程映射到内核中的进程(最小调度单位)，该操作被封装成系统调用。

因此本质上线程的创建操作是通过调用内核提供的API来实现一个完整的线程创建API

### 线程同步

进程在创建了所有需要的线程后进入阻塞态，等待所有线程执行完成，然后将处理器控制器转移给其他处于就绪态的进程。

线程的同步是由进程执行的，该操作的作用是**等待该进程创建的所有线程结束**。直接调用系统调用。

```cpp
    void thread_join(){
        __asm__("cli\n");
        调用系统调用
        __asm__("sti\n");
    }
```

该系统调用的功能实现如下：

```cpp
    void do_thread_join(){
        if(PCBaddr->thread>0){  // 该进程还有线程未执行完
            PCBaddr->STATUS=BLOCK;  // 进程置于阻塞态等待
            dispatch();         // 调度其他进程使用CPU
        }
    }
```

所以只有进程所创建的线程中有一个未执行完则进程进入阻塞态，不被调度。知道进程的所有线程执行完。

### 线程结束

根据上述，处理线程结束的函数的入口地址在线程创建时被压到线程栈里，在线程执行完成后会自动调用该函数。

线程有自己的控制块(TCB)，故线程结束时要释放该部分的资源，在我们的简单模型中内核需要记录现有的TCB，所以我们可以将已经结束的线程的TCB设置为未用来表示资源释放。

首先将线程对应的tid标记为未使用(回收该tid)，然后调用系统调用

```cpp
    void thread_exit(int tid){
        __asm__("cli\n");
        used[tid]=0;
        执行系统调用
        __asm__("sti\n");
    }
```

该系统调用的实现如下：

```cpp
    void do_thread_exit(){
        // 此时CPU所有者是该线程
        int fid=PCBaddr->FID;   // 创建给线程的进程的PID
        if(fid==-1) return ;    // 此时CPU的占有者非线程 或者 出现异常
        PCBlist[fid].threads-=1;
        // 进程的所有线程执行完 进程恢复到就绪态
        if(PCBlist[fid].threads==0) PCBlist[fid].STATUS=READY;
        // 线程设置为退出态
        PCBaddr->STATUS=EXIT;
        释放线程占用的PCB资源(可以将该PCB标记为未使用以供其他进程/线程使用)
        dispatch(); // 转移CPU控制权
    }
```

线程执行完时将创建它的进程的PCB中的计数器减1，通知进程有一个线程执行完成(但不能确定是哪一个)。
当进程所含的最后一个线程执行完成时，进程PCB中的计数器为0，这最后一个线程唤醒进程(将进程设置为就绪态)，使得进程可以参与接下来的调度。

### 封装

最终我将上述的关于线程的三个功能封装成一个线程库，用户程序在使用时调用该库便可以创建线程，具有可扩展性。而该线程库的内部都是调用了系统调用和内核函数。
