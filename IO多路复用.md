# I/O多路复用

## 原理

I/O多路复用(IO Multiplexing)是指单个进程/线程可以同时处理多个I/O请求

用户将要监视的文件描述符添加到select/poll/epoll函数中，由内核监视，函数阻塞。一旦有文件描述符就绪(读就绪或者写就绪)或者超时(设置timeout)，函数就会返回，然后该进程可以进行相应的读/写操作。

## I/O多路复用的三种机制

### 文件描述符

文件描述符是一个索引值，指向内核为每一个进程所维护的该进程打开的文件的记录表。这一概念往往只适用于Unix、Linux这样的操作系统。

### 缓存I/O

缓存I/O又称为标准I/O，大多数文件系统的默认I/O操作都是缓存I/O。Linux中操作系统还会将I/O的数据缓存在文件系统的页缓存中，即数据会先被拷贝到操作系统内核的缓冲区，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。

### select

将文件描述符放入一个集合中，调用select时该集合从用户空间拷贝到内核空间(开销大)，由内核根据就绪状态修改该集合的内容(集合大小有限制)。每次都需要遍历整个集合找到需要的文件描述符，时间复杂度O(n)。

### poll

与select的区别在于文件描述符的存储方式不同，poll采用链表的方式存储，故没有最大存储数量的限制。但select的其他限制poll也一样受限(开销大，需要遍历整个集合)。

### epoll

**基于事件驱动**的I/O，不需要遍历整个监听的文件描述符集合，只需要遍历被内核I/O事件异步唤醒而加入就绪队列的描述符集合即可。通过内核和用户空间共享内存，避免了不断复制描述符集合的问题。

epoll通过epoll_ctl函数将所有要监听的事件添加到红黑树中，所有添加的事件会与设备驱动程序建立回调关系，即当相应事件发生时会回调这个方法，它会将发生的事件添加到一个就绪链表中。

epoll为每个事件维护一个数据结构，当调用epoll_wait函数检查是否有事件发生时只需要检查上述就绪链表中是否有数据即可。

水平触发：只要一个文件描述符就绪就会触发通知，若用户程序没有一次性把数据读写玩，下次还会通知
边缘触发：当描述符从未就绪变为就绪时通知一次，之后不会再通知，直到再次从未就绪变为就绪态。

若系统中有大量不需要进程读写的就绪文件描述符，在每次调用epoll_wait时都会返回这些就绪的文件描述符，这会降低进程检索与自己有关的文件描述符的效率，故提出边缘触发机制。

epoll也有连接数上限，但比select多很多

## 算法选择

当连接数较多且有很多连接不活跃时，采用epoll的效率比较高。但当连接数较少且都十分活跃时，由于epoll采用了回调机制，性能可能有所下降。
