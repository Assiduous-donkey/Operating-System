# 死锁

## 什么是死锁

在两个或多个并发进程中，每个进程持有某种资源而又等待其他进程释放它们现在保持的资源，在未改变这种状态之前都不能继续执行，则称这组进程产生死锁。

## 死锁的条件

处于等待/阻塞状态的进程无法自己改变自己的状态，需要其他进程来改变。

1. 互斥条件：一段时间内某资源只能由一个进程占有。

2. 占有且等待条件：一个进程至少占有一个资源，且请求另一个被占用的资源，则该请求被阻塞，且该进程占有的资源不会被释放

3. 不可抢占条件：已经分配给一个进程的资源不能被强制性抢占，只能由进程完成任务之后自愿释放

4. 循环等待条件（充分条件）：存在一个封闭的进程链，使得每个进程至少占有此链中下一个进程所需要的一种资源。

5. 死锁的可能性：互斥条件、不可抢占条件和占有且等待条件

6. 死锁的存在性：上述四个条件同时存在

## 鸵鸟策略

直接忽略死锁，因为解决死锁问题的代价很高。当发生死锁的概率很低或者发生死锁不会对用户造成多大影响的时候可以采用鸵鸟策略。

## 死锁预防

基本思想是破坏死锁的必要条件

1. 破坏互斥条件：允许多个进程同时使用资源。但是某些资源可能本身不具备可以同时被多个进程访问的属性。

2. 破坏占有且等待条件：禁止已拥有资源的进程再申请其他资源，如要求进程在开始执行前一次性申请所有需要的资源，或申请资源时先释放其占有的资源后再一次性申请所需的全部资源。但会造成资源浪费以及进程延迟运行，且很多情况下无法预知进程所需的所有资源。

3. 破坏不可抢占条件：一个已经占有某些资源的进程在申请其他新资源但无法立即得到满足时必须先释放它占有的所有资源待以后需要时再重新申请。操作系统可以剥夺一个进程占有的资源并分配给其他进程。这种方法实现困难且开销大，会降低系统的性能。

4. 破坏循环等待条件：对所有资源进行统一编号，使资源线性排列，进程申请资源必须严格按照资源号递增的顺序。不过这样做容易造成资源浪费。

## 死锁避免

1. 基本方案：

    - 若一个进程的请求会导致死锁则不启动该进程。

    - 若一个进程增加的资源请求会导致死锁则不允许分配。

2. 基本思想：动态检测资源的分配状态，以确保系统处于安全状态。只有处于安全状态时才会进行资源分配。**安全状态指系统能按照某个顺序为每个进程分配资源使得当前所有进程都能运行到结束状态**。

3. 两种具体方法：资源分配图法和银行家算法。其中资源分配图法要求每种资源类型只有一个实例，一个实例包括申请边、分配边和需求边。当资源分配图不形成环才允许分配。而银行家算法适用于资源类型存在多个实例的清空。

## 银行家算法

1. 模型：

    - 系统状态由资源总量向量$R=(R_1,R_2,...,R_m)$、系统可用资源总量向量$V=(V_1,V_2,...,V_m)$、进程-资源需求矩阵C和进程-资源分配矩阵A表示。

    - 安全状态：至少存在一个执行时序（资源分配序列）使得当前所有进程都能运行到结束状态。

    - 只要系统处于安全状态，必定不会发生死锁。而**不安全状态不一定是死锁状态，但不能保证不会进入死锁**

    - 需要满足：总资源数=可用资源数+已分配资源数；要申请的资源数不超过资源总数；已分配的资源数不能超过对这个资源的请求数。

2. 避免策略：

    - 如果一个新进程的资源请求会导致不安全状态则拒绝启动这个进程

    - 如果满足一个进程新提出的资源请求会导致不安全状态，则拒绝分配资源给这个进程

3. 具体算法：

    - 全局数据结构：n个进程,m种资源。

        ```cpp
            struct state{
                int resource[m];    //resource[i]:第i种资源的总数
                int available[m];   //available[i]:第i种资源的剩余数量
                int claim[n][m];    //claim[i][j]:进程i对资源j的请求数
                int alloc[n][m];    //alloc[i][j]:进程i已经拥有的资源j的总数
            };
        ```

    - 资源分配算法：

        ```cpp
            if(alloc[i,*]+request[*]>claim[i,*]){
                // 进程i已分配的资源数和当前请求的资源数的总和不可超过进程申请的总资源数
            }
            else if(request[*]>available[*]){
                // 进程当前请求的资源数超过该资源的可用数量则挂起进程
                <suspend current process>
            }
            else{
                // 分配资源给进程 得到新的状态
                alloc[i,*]=alloc[i,*]+request[*];
                available[*]=available[*]-request[*];
            }
            // 检测当前状态是否安全 若不安全则恢复到未分配时的状态 决绝分配资源
            if(safe(newstate)==true){
                // 可以分配
            }
            else{
                // 恢复到未分配时的状态 挂起进程
            }
        ```

    - 测试安全算法：在进程集合中找到一个进程可以满足**进程申请的所有资源数减去已经分配的资源数小于当前可用的资源数**。如果找到满足条件的进程，则**将该进程还需要的资源都分配给该进程并让其执行完成然后释放占有的所有资源以供其他进程使用**。若不满足则恢复到原始状态，不分配资源给该进程

        ```cpp
            bool safe(state newstate){
                int cur_available[m]=available;
                process p_set[n]={all processes}
                possible=true;
                while(possible==true){
                    <在p_set中找一个进程k满足:
                    claim[k,*]-alloc[k,*]<=cur_available;>
                    if(找到满足条件的进程k){
                        // 让进程K得到所需的所有资源并执行完成
                        cur_available=cur_available+alloc[k,i]
                        p_set=p_set-{process_k};
                    }
                    else{
                        possible=false;
                    }
                }
                return p_set==NULL;
            }
        ```

4. 优点：比死锁预防的限制少，且无需死锁预防中的资源剥夺和进程重启。

5. 缺点：必须事先声明每个进程请求的最大资源数，且考虑的进程的执行顺序必须**没有任何同步要求的限制**。

## 死锁检测

利用资源分配图看是否有环，或采用类似银行家算法的安全状态检测算法

## 死锁恢复

1. 抢占资源：连续剥夺资源直到不再存在死锁

2. 回退：把每个死锁进程回滚到前面定义的某些足以解除死锁的检查点并重新启动所有进程。（回退过程中释放占有的资源）

3. 强制杀死进程：强制杀死某些进程直到所有死锁解除为止。

## 死锁避免、检测与预防之间的区别

1. 预防是通过限制三种死锁的必要条件中的至少一个或者直接限制循环等待的发生。

2. 避免允许可能出现的必要条件发生，但采取措施防止系统进入不安全状态，确保不出现死锁。

3. 检测是允许资源自由分配，采取周期性的措施来发现并处理可能存在的死锁情况。（处理死锁————死锁恢复）

## 哲学家就餐问题

1. 问题描述：5个哲学家围成一圈吃意大利面，共5把叉子。一个哲学家需要用两把叉子吃面。怎么吃才能避免死锁和饥饿？

2. 信号量的解决方案：

    ```cpp
        semaphore forks[5]={1,1,1,1,1}; // 5把叉子
        semaphore people=4;

        // 五个哲学家编号0,1,2,3,4
        // semaphore people 防止循环且等待
        void philosopher(int i){
            while(true){
                think();    // 哲学家思考
                P(people);
                // 每人拿左右两把叉子
                P(forks[i]);
                P(forks[(i+1)%5]);
                eat();  // 就餐
                V(forks[(i+1)%5]);
                V(forks[i]);
                V(people);
            }
        }

        int main(){
            // 5位哲学家
            philosopher(0);
            philosopher(1);
            philosopher(2);
            philosopher(3);
            philosopher(4);
        }
    ```
