# 进程与线程

## 进程

1. 进程的定义有很多，比如：

    - 一个执行中程序的实例

    - 程序在一个数据集上的运行过程

    总之，进程是系统进行资源分配和调度的独立单位。

2. 进程控制块(PCB)，是描述进程的数据结构，且用于进程的管理和调度，**由操作系统维护**。包含以下信息（非全部）：

    - 标识符：包括唯一的进程ID，父进程标识符

    - 进程当前的状态

    - 进程的优先级

    - 程序计数器，保存将被执行的下一条程序指令的地址

    - 内存指针，包括执行程序代码、相关数据和共享内存的指针

    - 上下文数据，即进程被中断时处理器和寄存器中的数据

3. PCB的组织方式有链接式和索引式：

    - 链接式：同一状态的进程的PCB组成一个链表，不同状态对应不同的链表

    - 索引式：同一状态的进程的PCB归入一个索引表，不同状态对应不同的索引表

4. 进程实体是由**程序段、数据段以及进程控制块**等部分组成，称为**进程映像**。具体包括：

    - 用户数据和用户程序

    - 系统栈（跟踪过程调用和过程间参数传递）

    - 进程控制块PCB，由OS维护的用于记录和控制进程属性的集合

5. 进程的创建过程：

    - 建立管理进程的数据结构PCB

    - 为进程分配内存空间

    - 创建进程映像，包括初始化PCB

    - 将进程插入就绪队列

6. 进程的阻塞由进程自身主动执行，进程的唤醒由其他进程执行。

7. 进程切换过程：

    - 保护处理器的上下文环境

    - 更新当前处于运行态的进程的PCB中的控制信息

    - 将该进程插入相应的队列（就绪、阻塞等）

    - 选择一个就绪的进程

    - 更新所选进程的PCB

    - 更新存储管理数据结构

    - 恢复被选中的进程的处理器上下文

## 僵尸进程

1. 一个不再执行或者执行完但没有被真正销毁的进程。它已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程表中保留一个位置，记载该进程的进程ID、终止状态以及资源利用信息供父进程收集。

2. 僵尸进程可能一直留在系统中直到系统重启

3. 占用进程号，而系统所能使用的进程号是有限的。

## 孤儿进程

一个父进程已经结束，但它的子进程还在运行，那么子进程称为孤儿进程。孤儿进程会被init(进程ID=1)的进程接管，当这些孤儿进程结束时由init完成状态收集工作。

## 线程

1. 线程是一个进程内CPU的基本调度单位

2. 同一个进程内的所有线程共享进程代码和地址空间，即线程的CS和DS与进程的相同。线程可以拥有少量私有资源，包括自己的寄存器上下文和栈空间，用于存储局部变量和调用参数，运行期间可以拥有CPU资源

3. 优点：

    - 在已有的进程内创建速度快

    - 终止线程所用的时间少

    - 线程切换需要的时间少，保存和恢复的工作量小

    - 通信效率高，在同一进程内无需调用OS内核，可利用共享的存储空间

    - 占用的资源少（使得线程有了其他优点）

4. 线程的分类：

    - 用户级线程：线程管理由应用程序完成，与内核无关。内核不知道线程的存在。这种类型的线程在线程切换时不需要进行模式切换，故不需要内核支持，线程库可以在任何操作系统上运行，调度算法可以是应用程序的专用算法。但是这种线程，一个线程阻塞会导致整个进程阻塞，因为该进程的所有线程对内核来说是同一个调度实体。

    - 内核级线程：线程管理由内核提供的API完成，内核调度是基于线程进行的，故线程的阻塞不会导致对应进程的阻塞。不过线程切换需要进行模式切换，开销大。

## 进程和线程的区别

1. 进程是资源分配的基本单位，线程是资源调度的基本单位

2. 多线程环境下，进程是拥有系统资源的基本单位，包含多个线程。线程本身无法直接调用系统资源，而进程本身不再作为可执行的实体，只负责为线程提供资源。一个进程的执行实际上是进程中某个线程的执行。

3. 进程实现了操作系统的并发，线程实现了进程内部的并发

4. 进程在执行过程中有独立的内存单元，而多个线程共享进程的内存

## 为什么线程切换的开销比进程切换的开销小

1. 调度的开销主要是**上下文切换的开销**。线程存在与进程中，一个进程可以有一个或多个线程。线程的上下文就是进程上下文的子集，故切换时要保存的上下文小，开销自然就小。
也可以这样解释，多个同类进程需要占用多份资源，而一个进程中的多个同类线程则共享一份资源。
但在Linux中，进程和线程都是用同样的数据结构表示，只是表示线程时可以多个线程指向同一内存地址表示这些线程来自同一个进程。因此在这一点上的开销，进程和线程就没差别了。

2. 任务调度之后，CPU可能发生缺页中断产生的开销。根据上述，来自同一进程的多个线程共享某一内存空间，所以CPU的Cache/TLB命中率会比较高，意味着缺页中断少，那开销就小了。

## 进程调度策略

1. FCFS：先来先服务，由队列实现，是非抢占的。先请求CPU的进程先分配到CPU

2. 最短作业优先调度算法：选择平均等待时间最短的进程作为下一个要运行的进程。

3. 优先级调度算法：优先级越高越先分配到CPU，相同优先级先到先服务。可能会造成低优先级的进程饥饿。

4. 时间片轮转调度算法：队列中的进程每次被分配不超过一个时间片的CPU时间。这种方法有利于CPU密集型的进程，但不利于I/O密集型进程。因为I/O密集型进程在阻塞后被唤醒时又回到了队尾，执行性能降低。为此提出改进方法————虚拟轮转法(VRR)。
虚拟轮转法：当一个进程因为I/O而被阻塞时，它加入一个I/O队列，解除了I/O阻塞的进程都被转移到一个采用FCFS的辅助队列中，**进行进程调度时辅助队列中的进程优先于就绪队列中的进程被调用**。

5. 多级队列调度算法：就绪队列分成多个独立的队列，每个队列都有自己的调度算法，队列之间采用固定优先级抢占调度。一个进程根据自身属性被永久地分配到某个队列中。

6. 多级反馈队列调度算法：同上，但允许进程在队列之间移动。若进程使用过多的CPU时间那么它会被转移到更低的优先级队列。具体特点如下：

    - 具有多个优先级的就绪队列，**优先级越高的队列每次分配的时间片越小**，按如下规则：（优先级）0,1,2,...（时间片）1,$2^1$,$2^2$,...

    - 新的就绪进程进入最高优先级队列

    - 进程由于时间片用完被抢占而放弃CPU，并**下降一个优先级**，即移动到低一级队列的队尾。若不是被抢占则不用降级。

    - 进程由于等待而放弃CPU后进入等待队列，一旦等待的事件发生，则回到原来的就绪队列。

    - 各优先级队列采用先到先服务的策略

    - 处于最低优先级的队列中的进程，即使被抢占也不会降级，只会继续排到队尾。
