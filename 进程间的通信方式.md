# 理论知识

## 进程间的通信方式

### 管道

1. 管道的特点

    - 管道是半双工的，**数据只能在一个方向上传输**

    - 一个进程向管道中写的内容被另一个进程读出，写入的内容添加到管道缓冲区末尾，且每次都是从缓冲区的头部读出数据。

    - 管道只能用于具有亲缘关系的进程之间通信，如父子进程或者兄弟进程。

    - 管道可以看作是一种特殊的文件，对它的读写可以使用普通的read和write函数，但它不是普通的文件，不属于其他任何文件系统，且只存在于内存。

2. 匿名管道

    - 建立管道时会在内核中申请一块固定大小的缓冲区，并创建两个文件描述符，其中fd[0]执行读操作，fd[1]执行写操作。要关闭管道只需要关闭两个涉及读和写的文件描述符即可。**这两个文件描述符实际上指向同一个文件(inode)，只不过一个是只读一个是只写**。

    - 单个进程中的管道几乎没有用处，通常是调用了fork的进程形成父子进程，父子进程直接用管道通信。若要数据从父进程传输到子进程则关闭父进程的读端和子进程的写端。也可以让数据从子进程流向父进程。但记住，管道是半双工的，要改变数据传输方向就要重新分配读端和写端。

    - linux的实现是申请一个缓冲区作为管道的文件实体，设置一个读指针和一个写指针并保证读指针的移动不超过写指针。

    - 如下，创建从父进程到子进程的管道：

        ```cpp
            #include<unistd.h>
            int main(){
                int fid[2];     // 两个文件描述符
                pid_t pid;      // 子进程PID
                char buff[128]; // 缓冲区

                if(pipe(fid)<0){    // 创建管道
                    // 创建管道失败
                }

                if((pid=fork())<0){ // 创建子进程
                    // 创建子进程失败
                }
                else if(pid>0){     // 父进程
                    close(fid[0]);  // 关闭读端
                    write(fid[1],"传给子进程的信息",传递的字节数)
                }
                else{               // 子进程
                    close(fid[1]);  // 关闭写端
                    read(fid[0],buff,缓冲区大小);
                }

                return 0;
            }
        ```

### 命名管道(FIFO)

1. 特点

    - 可以在无关的进程之间交换数据

    - FIFO是一种文件类型，有路径名与之相关联，以一种特殊设备文件形式存在于文件系统中。一旦创建了一个命名管道FIFO，就可以用一般的文件I/O函数操作它。

    - 同匿名管道，也是半双工单向通信。

    - FIFO的通信方式类似与在进程中使用文件来传输数据，不过FIFO类型文件同时具有管道的特性。在数据读出时管道同时清除数据且遵循先进先出的原则。

2. 通信过程类似于**客户端-服务端模型**，**客户端写，服务端读**。所以需要写进程和读进程，一个服务器可以接受多个客户端的请求，那么一个读进程可以接收多个写进程的信息，读进程检查缓冲区，当发现缓冲区有数据则读出数据并处理即可。但关键的是，每一个客户端必须知道服务器提供的接口，即**每一个写进程需要知道读进程提供的FIFO接口**。

3. 读进程：

    ```cpp
        int main(){
            int fid;        // 文件描述符
            char buf[128];  // 缓冲区
            int length;     // 信息的长度

            if(mkfifo("接口",0666)<0){  // 创建FIFO管道 0666是文件权限
                // 创建管道失败
            }

            if((fid=open("接口",O_RDONLY))<0){  // 以读方式打开FIFO
                // 打开文件失败
            }

            while((length=read(fid,buf,128))>0){
                // 读取FIFO中的信息
            }

            close(fid);
            return 0;
        }
    ```

4. 写进程:

    ```cpp
        int main(){
            int fid;
            char buf[128];

            if((fid=open("接口",O_WRONLY))<0){
                // 打开FIFO失败
            }

            // 将数据写入buf

            if(write(fid,buf,数据长度)<0){  // 将buf中的数据写入管道
                // 写入管道失败
                close(fid);
                exit(1);
            }

            close(fid);
            return 0;
        }
    ```

### 为什么管道只能单向通信

管道用一个缓冲区来存放消息，若一个进程既可写入又去读出，那可能出现进程A写入要传给进程B的消息后自己又把该消息读出来。所以同一管道是不可以双向通信的。

### 消息队列

1. 特点

    - 消息队列是**内核**中一个链表，链接节点存放数据报的类型和内容（一般是自定义的结构体），用标识符进行标记。

    - 消息队列中的**消息具有特定的格式以及特定的优先级**

    - 消息队列独立于发送与接收进程，进程终止时消息队列及其内容并不会被删除，生命周期随内核。

    - 可以实现消息的随机查询而不一定要以先进先出的顺序读取

    - 允许一个或多个进程读写消息，且可以实现双向通信

2. 双向通信的实现：消息队列中可以存放不同类型的消息，若进程A和进程B通信，要实现双向通信，可以是进程A只往消息队列中添加类型1的消息，且只从消息队列中取出类型2的消息；而进程B只往消息队列中添加类型2的消息且只从消息队列中取出类型1的消息。

### 信号量

1. 信号量实际上是一个计数器，用于实现进程间的互斥和同步，而不是用于存储进程间的通信数据，若要在进程间传递数据需要结合共享内存。

2. 两个原子操作和初始化操作：

    - 初始化：将信号量的值初始化为一个非负整数，表示可用的资源数

    - P操作：将信号量的值减1，表示申请一个单位的资源。当信号量的值变为负数时，说明资源已经分配完，执行该P操作的进程需要等待。

    - V操作：将信号量的值加1，表示释放一个单位的资源，同时让一个因为执行P操作而被阻塞的进程解除阻塞。若信号量的值不是正数，则其绝对值表示被阻塞的进程数。

3. 信号量实现互斥：每个进程进入临界区之前执行P操作，离开临界区之后执行V操作

4. 信号量实现同步：每一个同步关系需要一个信号量，同步关系分为前驱动作和后继动作，前驱动作执行完做V操作，解除阻塞；后继动作执行前做P操作，保证同步。

### 共享内存

1. 指两个或多个进程共享一个给定的存储区。

2. **共享内存是最快的一种进程间通信方式(IPC)**，因为是进程直接对内存进行存取。

3. 多个进程可以同时操作共享的内存，所以需要进行同步，故共享内存经常结合信号量一起使用。

4. 正式点说，就是让进程地址通过页表映射到同一片物理地址以进行通信。
