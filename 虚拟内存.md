# 虚拟内存

## 什么是虚拟内存

每个程序都有自己的地址空间，这个地址空间被分成大小相等的页，这些页被映射到物理内存，但不需要所有的页都在物理内存中。当程序引用不在物理内存中的页时，由操作系统将缺失的部分装入物理内存。
对于程序来说，逻辑上似乎有很大的内存空间，但实际上有一部分是存储在磁盘上的，因此叫做虚拟内存。

## 内存管理单元(MMU)

管理逻辑地址和物理地址的转换

## 页式管理

基于分页的虚拟内存方案中，通常**每个进程都有一个唯一的页表，对应于每个进程都有自己的虚拟地址空间**。

### 页表

**页表存储着页(逻辑地址)和页框(物理内存空间)的映射表**。还包括有效位(该页存在于内存还是磁盘)、访问位(该页是否被访问过)、修改位(该页在内存中是否被修改过)以及保护位(该页的操作权限，只读还是可读写)

其中修改位也称为脏位，表示相应的页的内容从上一次装入内存中到现在是否已经改变。若未改变则当需要把该页换出时，不需要用页框中的内容更新该页。即不需要将页框中的内容写回磁盘。

由于页表的长度可以基于进程的长度而变化，因此页表必须保存在可以访问到的内容中。

### 页表的地址转换

当一个进程正在运行时，**一个寄存器保存该进程页表的起始地址**。逻辑地址(由页号和偏移量组成)的页号用于检索页表(可以看作是页表的索引，即页表项相对于页表起始地址的位置)，查找对应的页框号。然后将页框号与逻辑地址中的偏移量组合起来产生对应的物理地址。

### 多级页表

当页表过大时可以采用多级页表的形式，主要有二级页表，即创建**页表的页表**

以虚拟地址空间32位(4GB)为例(逻辑地址最多为32位)，若页面大小为4KB($2^12$)，则一个页表共有1M个页表项(4GB/4KB=1M,$2^20$)。一个页表项包含了一个页框号，指向内存中的具体页框。若每条页表项占用4B，则一个页表需要占用4MB的内存。

若使用二级页表，则将原来的页表再分为大小相同的页(每个页存放的都是页表项)，再建立对应的索引(新的表项)，新的表项存在第一级页表中。第二级页表则存储到实际页框的映射。
假设第一级页表中每个页表项映射的范围是4MB，第一级页表共有1K(4GB/4MB)个页表项。每个页表项映射的范围是4MB，且页面大小为4KB，故**第一级页表的一个表项可以映射到1K(4MB/4KB)个页框，即第二级页表每个页表有1K个页表项**。
故该二级页表共占用的内存是：1K*4B(第一级页表占用的内存)+1K\*1K\*4B(第二级页表占用的内存)=4.004MB
看似比原来占用的内存还多，实际上可以通过以下方法来节约内存：

1. **第二级页表可以不存在，可以在需要时才创建**。每个进程有4GB的虚拟地址空间，但实际上远远不需要完全使用这些空间。

    - 使用一级页表时，操作系统通过虚拟地址中的页号去页表查找对应的页表项，因此一级页表需要覆盖全部虚拟地址空间才能够保证每一次根据页号查找时都用找到对应的页表项，否则系统会出错。

    - 使用二级页表时，也需要覆盖全部地址空间，但其第一级页表已经覆盖了全部虚拟地址空间(其中每一个页表项映射到虚拟地址空间中的4MB).若对于进程来说，这4MB实际上不需要用到，则可以不创建该表项对应的第二级页表，这就起到了节省空间的作用。

2. **第二级页表可以不再主存中**。根据进程运行的局部性原理，可以将第二级页表放在磁盘中，在需要时才调入内存。这是时间换空间的做法。

### 局部性原理

1. 空间上：内存中被访问的页周围的页也很可能被访问

2. 时间上：最近被访问的页在不久的将来可能还会被访问

### 页的尺寸设置

页越小则每个进程需要的页的数目越多，意味着需要有更大的页表，则进程有一部分页表在虚存中而不是在内存中。从而**一次内存访问可能产生两次缺页中断**。第一次是在内存在读取不到所需的页表项，第二次是读取不到所需的页。

1. 小页面有利于减少内部碎片

2. 大页面有利于减少进程的页表容量

3. 大页面有利于实现有效的磁盘数据块传输

### 颠簸现象

本质上是指频繁的页面调度行为(从磁盘到内存)。

## 转换检测缓冲区

原则上每次虚存访问可能引起两次物理内存访问，一次是取相应的页表项，一次是取查找到的页帧中的数据。大多数虚拟内存方案为页表项提供了一个特殊的高速缓存，通常称为转换检测缓冲区(TLB)，**包含了最近使用过的页表项**。

给定一个虚拟地址，处理器首先检查TLB。若需要的页表项在TLB中则称为命中；若未找到则处理器需要用逻辑地址中的页号取内存检索页表。
若找到的页表项中的“存在位”已经置位，则表示该页在内存中，处理器从页表项中检索出页框号，同时更新TLB，使其包含该表项。
若页表项中的“存在位”没有置位则表示需要的页不在内存中，这将产生一次内存访问故障，称为“缺页中断”。这是需要操作系统来装入需要的页并更新页表。

在页表中查找页表项是直接映射，在TLB中查找页表项是关联映射，由硬件实现。

## 页面置换算法

当需要调入页但内存已满时，决定要置换内存中的哪个页面。

1. 最优算法OTP：置换内存中**未来不再使用**或者**还要最长时间才会使用**的那个页。(不可能实现)

2. 最近最少使用算法LRU：淘汰内存中**最长时间未使用**的页面。根据局部性原理(CPU访问存储器时，无论是存去指令还是存去数据，所访问的存储单元都趋于聚集在一个较小的连续区域中)，这是最近最不可能访问到的页。

3. 先进先出算法FIFO：淘汰内存中**驻留时间最长**的页。可能会造成颠簸(抖动)现象。

4. **时钟算法CLOCK**：采用环形链表的形式，需要一个移动指针。每个页关联一个**使用位(表明最近有没有被使用过)**，在页装入内存和被访问时使用位置1。当一个页被置换或者仅仅换入一个空页框时，指针指向环中的下一个页框。在选取置换的页框时，指针扫描环形链表，每遇到一个使用位为1的页框就将该位置置0，直到遇到一个使用位为0的页框，则选择该页框进行置换。

### LRU的实现

1. 链表形式：每次内存访问后在链表中找到对应的页面，把该页面移到表头，因此表尾就是最久未使用的页

2. 时间戳形式：每个页添加一个最后一次访问的时间戳并在每次访问时更新这个时间戳。

## Belady现象

在分页式虚拟存储管理中，采用FIFO作为缺页置换算法，如果一个进程未分配它所要求的所有页面，有时会出现**分配的页面数增多但缺页率反而提高**的异常现象。

## 段式管理

页式管理对程序员来说是不可见的，而段式管理则是可见的。页的大小是一定的，而段的大小是不定的，动态的。内存访问以段号和偏移量的形式组成地址。

与页式管理类似，每个进程都一张段表，存在的内存中，进程的段表起始地址保存在一个专用的寄存器中。

与非段式地址空间相比有以下优点：

1. 简化了对不断增长的数据结构的处理。操作系统可以在需要时扩大或缩小一个段来适应其中的数据结构。

2. 允许程序独立地改变或重新编译。

3. 有助于进程间的共享。可以在某个段中放置一个工具程序或数据表使得其他进程可以通过访问这个段来调用工具或者获取数据。

4. 可以方便的指定段的访问权限。
